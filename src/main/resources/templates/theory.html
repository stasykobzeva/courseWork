<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Теория по уровню</title>
    <link rel="stylesheet" th:href="@{/css/stylesLev.css}" />
    <style>
        .theory-container {
            background-color: rgba(255, 255, 255, 0.3);
            width: 80%;
            max-width: 800px;
            margin: 20px auto;
            box-sizing: border-box;
            padding: 20px;
            border-radius: 10px;
            color: #fff;
            line-height: 1.6;
            font-size: 18px;
        }

        h1 {
            text-align: center;
            color: #fff;
        }

        p {
            margin-bottom: 10px;
        }

        img {
            display: block;
            margin: 15px auto;
            max-width: 100%;
            border-radius: 10px;
        }
    </style>
</head>

<body>
    <header>
        <nav class="menu">
            <ul>
                <li>
                    <a th:href="@{/}">Главная</a>
                    <ul>
                        <li><a th:href="@{/register}">Регистрация</a></li>
                        <li><a th:href="@{/login}">Вход</a></li>
                    </ul>
                </li>
                <li>
                    <a th:href="@{/game}">Играть</a>
                    <ul>
                        <li><a th:href="@{/profile}">Меню</a></li>
                        <li><a th:href="@{/book}">Справка</a></li>
                    </ul>
                </li>
                <li>
                    <a th:href="@{/contacts}">Контакты</a>
                </li>
            </ul>
        </nav>
    </header>

    <h1 id="level-title">Название уровня</h1>

    <div class="theory-container" id="theoryContent">
        Здесь будет теоретический материал.
    </div>

    <footer>
        © 2025 Все права защищены
    </footer>

    <script>
        // Получаем номер уровня
        const params = new URLSearchParams(window.location.search);
        const level = parseInt(params.get('level'));

        // Теоретические материалы по уровням
        const theoryData = {
            1: `
                <p><b>Шифр Цезаря</b> — один из самых древних и простых способов шифрования. 
                Каждая буква заменяется другой, находящейся на фиксированное число позиций 
                в алфавите. Например, при сдвиге на 3: А→Г, Б→Д, В→Е.</p>
                <p>Шифр легко реализовать вручную, но он неустойчив к анализу частотности, 
                поэтому применяется только для обучения и демонстрации принципов подстановки.</p>
                <img src="/images/caesar_table.png" alt="Таблица сдвига Цезаря">
            `,
            2: `
                <p>Двойное применение шифра Цезаря с одинаковым сдвигом эквивалентно 
                одному сдвигу, равному сумме двух. Например, дважды сдвинув текст на 3 позиции, 
                получим тот же результат, что и при сдвиге на 6.</p>
            `,
            3: `
                <p><b>Аффинный шифр</b> — это развитие идеи Цезаря. Используется формула:
                <br>E(x) = (a * x + b) mod n.</p>
                <p>Ключ состоит из двух чисел a и b. Число a должно быть взаимно простым с n (размером алфавита).</p>
            `,
            4: `
                <p><b>Шифр Виженера</b> — это полиалфавитный шифр, в котором для каждой буквы 
                используется отдельный сдвиг, определяемый ключом. Ключ повторяется по длине текста.</p>
                <p>Таблица Виженера позволяет определить соответствие каждой буквы исходного и зашифрованного текста.</p>
                <img src="/images/vigenere_table.png" alt="Таблица Виженера">
            `,
            5: `
                <p><b>Взлом шифра Виженера</b> возможен методом Касиски или частотного анализа. 
                Определив длину ключа, можно анализировать каждую его часть как отдельный шифр Цезаря.</p>
            `,
            6: `
                <p><b>Шифр Вернама</b> основан на операции XOR между сообщением и ключом такой же длины. 
                При использовании одноразового ключа он абсолютно стойкий.</p>
            `,
            7: `
                <p><b>Шифр Плейфера</b> использует таблицу 5×5, заполненную буквами алфавита. 
                Каждая пара букв (биграмма) шифруется в зависимости от их положения в таблице.</p>
                <img src="/images/playfair_table.png" alt="Таблица Плейфера">
            `,
            8: `
                <p><b>Протокол Диффи–Хеллмана</b> предназначен для безопасного обмена ключами по открытому каналу. 
                Его стойкость основана на сложности вычисления дискретного логарифма.</p>
            `,
            9: `
                <p><b>Хэш-функция</b> — это способ одностороннего преобразования данных в фиксированную длину. 
                Результат (хэш) нельзя обратить обратно. Используется для проверки целостности и хранения паролей.</p>
            `,
            10: `
                <p><b>DES (Data Encryption Standard)</b> — блочный симметричный шифр с ключом длиной 56 бит. 
                Использует перестановки и замены (S-блоки). Позже был заменён на AES из-за недостаточной длины ключа.</p>
            `,
            12: `
                <p><b>AES (Advanced Encryption Standard)</b> — современный симметричный блочный шифр с длиной ключа 128, 192 или 256 бит. 
                Состоит из нескольких раундов перестановок, замен и операций XOR. Используется повсеместно.</p>
            `
        };

        const titleElement = document.getElementById('level-title');
        const contentElement = document.getElementById('theoryContent');

        if (theoryData[level]) {
            titleElement.innerText = `Теория по уровню ${level}`;
            contentElement.innerHTML = theoryData[level];
        } else {
            titleElement.innerText = 'Теоретический материал отсутствует';
            contentElement.innerHTML = '<p>Для этого уровня пока нет теоретического материала.</p>';
        }
    </script>
</body>

</html>